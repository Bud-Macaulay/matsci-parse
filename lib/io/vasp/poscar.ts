import { CrystalStructure, Site, CartesianCoords } from "../crystal";

/* 
derived from VASP documentation: www.vasp.at/wiki/POSCAR
*/

export function structureToPoscar(structure: CrystalStructure): string {
  const lines: string[] = [];

  lines.push("Generated by CrystalStructure");
  lines.push("1.0");

  // Lattice vectors
  structure.lattice.forEach((v: CartesianCoords) => {
    lines.push(v.map((x) => x.toFixed(10)).join(" "));
  });

  // Species line
  lines.push(structure.species.join(" "));

  // Species counts
  const counts = structure.species.map(
    (_, i) => structure.sites.filter((s) => s.speciesIndex === i).length,
  );
  lines.push(counts.join(" "));

  // Coordinate system
  lines.push("Cartesian");

  // Atomic positions (grouped by species)
  structure.species.forEach((_, i) => {
    structure.sites
      .filter((s) => s.speciesIndex === i)
      .forEach((s) => {
        lines.push(s.cart.map((x) => x.toFixed(10)).join(" "));
      });
  });

  return lines.join("\n");
}

export function poscarToStructure(poscarString: string): CrystalStructure {
  const lines = poscarString
    .trim()
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  let i = 0;

  i++; // skip comment line

  const scale = parseFloat(lines[i++]);

  // lattice
  const lattice: CartesianCoords[] = [];
  for (let j = 0; j < 3; j++) {
    lattice.push(
      lines[i++]
        .split(/\s+/)
        .map((x) => parseFloat(x) * scale) as CartesianCoords,
    );
  }

  // species line or skip
  let speciesLine = lines[i].trim();
  let species: string[] | undefined;
  if (/^[A-Za-z]/.test(speciesLine)) {
    species = speciesLine.split(/\s+/);
    i++;
  }

  // counts
  const counts: number[] = lines[i++].split(/\s+/).map(Number);

  // if species was missing, create placeholders
  if (!species) {
    species = counts.map((_, idx) => `X${idx + 1}`);
  }

  // selective dynamics optional
  let selectiveDynamics = false;
  if (lines[i]?.toLowerCase().startsWith("s")) {
    selectiveDynamics = true;
    i++;
  }

  // coordinate type
  const coordType = lines[i++].toLowerCase();
  const isDirect = coordType.startsWith("d");

  const sites: Site[] = [];
  species.forEach((_, speciesIndex) => {
    for (let n = 0; n < counts[speciesIndex]; n++) {
      const parts = lines[i++].split(/\s+/).map(Number);
      let cart: CartesianCoords;

      if (isDirect) {
        // fractional â†’ cartesian
        cart = [
          parts[0] * lattice[0][0] +
            parts[1] * lattice[1][0] +
            parts[2] * lattice[2][0],
          parts[0] * lattice[0][1] +
            parts[1] * lattice[1][1] +
            parts[2] * lattice[2][1],
          parts[0] * lattice[0][2] +
            parts[1] * lattice[1][2] +
            parts[2] * lattice[2][2],
        ] as CartesianCoords;
      } else {
        cart = parts.slice(0, 3) as CartesianCoords;
      }

      let selective: boolean[] | null = null;
      if (selectiveDynamics) {
        selective = lines[i - 1]
          .split(/\s+/)
          .slice(3, 6)
          .map((x) => x.toUpperCase() === "T");
      }

      sites.push(new Site(speciesIndex, cart));
    }
  });

  return new CrystalStructure({
    lattice,
    species,
    sites,
  });
}
