import { CrystalStructure } from "../crystal";
import { CartesianCoords, Site } from "../common";

import { hasSelectiveDynamics } from "../common";
import { stringToLines } from "../utils";

/* 
derived from VASP documentation: www.vasp.at/wiki/POSCAR
*/
export function structureToPoscar(
  structure: CrystalStructure,
  precision: number = 6,
): string {
  const lines: string[] = [];

  const useSelective = hasSelectiveDynamics(structure);

  lines.push("Generated by matsci-parse");
  lines.push("1.0");

  // lattice
  structure.lattice.forEach((v) => {
    lines.push(v.map((x) => x.toFixed(precision)).join(" "));
  });

  // --- compute unique species and counts ---
  const uniqueSpecies = Array.from(
    new Set(structure.sites.map((s) => structure.species[s.speciesIndex])),
  );
  const counts = uniqueSpecies.map(
    (el) =>
      structure.sites.filter((s) => structure.species[s.speciesIndex] === el)
        .length,
  );

  lines.push(uniqueSpecies.join(" "));
  lines.push(counts.join(" "));

  if (useSelective) lines.push("Selective dynamics");

  lines.push("Cartesian");

  // --- write coordinates grouped by species ---
  uniqueSpecies.forEach((el) => {
    structure.sites
      .filter((s) => structure.species[s.speciesIndex] === el)
      .forEach((s) => {
        const coords = s.cart.map((x) => x.toFixed(precision)).join(" ");
        if (useSelective) {
          const flags = Array.isArray(s.props?.selectiveDynamics)
            ? s.props.selectiveDynamics
            : [true, true, true];
          const sd = flags.map((f) => (f ? "T" : "F")).join(" ");
          lines.push(`${coords} ${sd}`);
        } else {
          lines.push(coords);
        }
      });
  });

  return lines.join("\n");
}

export function parsePoscar(lines: string[]): {
  structure: CrystalStructure;
  linesConsumed: number;
} {
  let i = 0;

  i++; // comment
  const scale = parseFloat(lines[i++]);

  const lattice: CartesianCoords[] = [];
  for (let j = 0; j < 3; j++) {
    lattice.push(
      lines[i++]
        .split(/\s+/)
        .map((x) => parseFloat(x) * scale) as CartesianCoords,
    );
  }

  let speciesLine = lines[i].trim();
  let species: string[] | undefined;
  if (/^[A-Za-z]/.test(speciesLine)) {
    species = speciesLine.split(/\s+/);
    i++;
  }

  const counts: number[] = lines[i++].split(/\s+/).map(Number);

  if (!species) {
    species = counts.map((_, idx) => `X${idx + 1}`);
  }

  let selectiveDynamics = false;
  if (lines[i]?.toLowerCase().startsWith("s")) {
    selectiveDynamics = true;
    i++;
  }

  const coordType = lines[i++].toLowerCase();
  const isDirect = coordType.startsWith("d");

  const sites: Site[] = [];

  species.forEach((_, speciesIndex) => {
    for (let n = 0; n < counts[speciesIndex]; n++) {
      const parts = lines[i++].split(/\s+/).map(Number);

      let cart: CartesianCoords;
      if (isDirect) {
        cart = [
          parts[0] * lattice[0][0] +
            parts[1] * lattice[1][0] +
            parts[2] * lattice[2][0],
          parts[0] * lattice[0][1] +
            parts[1] * lattice[1][1] +
            parts[2] * lattice[2][1],
          parts[0] * lattice[0][2] +
            parts[1] * lattice[1][2] +
            parts[2] * lattice[2][2],
        ] as CartesianCoords;
      } else {
        cart = parts.slice(0, 3) as CartesianCoords;
      }

      const props: Record<string, unknown> = {};

      if (selectiveDynamics) {
        const flags = parts.slice(3, 6).map((x) => x === 1);
        if (flags.length === 3) props.selectiveDynamics = flags;
      }

      sites.push(new Site(speciesIndex, cart, props));
    }
  });

  return {
    structure: new CrystalStructure({ lattice, species, sites }),
    linesConsumed: i,
  };
}

export function poscarToStructure(poscarString: string): CrystalStructure {
  const lines = stringToLines(poscarString);
  return parsePoscar(lines).structure;
}
